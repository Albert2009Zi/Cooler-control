
# 1 "C:\Program Files\Microchip\Project\SingleChipPlayer\ufat\ufat.c"

# 4 "C:\Program Files\Microchip\Project\SingleChipPlayer\ufat\ufat.h"
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned char bool;

# 28
bool ufatExtRead(u32 sector, u16 offset, u8 len, u8* buf);

void ufatInit(void);
bool ufatMount(void);
bool ufatGetNthFile(u16 n, char* name, u32* sz, u8* flags, u16* id);
bool ufatOpen(u16 id);
bool ufatGetNextSectorRange(u32* first, u32* len);

# 14 "C:\Program Files\Microchip\Project\SingleChipPlayer\ufat\ufat.c"
static u32 diskOffset = 0;
static u8 secPerClus;
static u16 rootDirEntries;
static u16 sectorsPerFat;
static u16 fatSec;
static u16 rootSec;
static u16 dataSec;
static u16 curClus = 0xffff;


static bool ufatParsePartitionTable(void){

char record[16];
u16 offset;

if(diskOffset) return 0;

for(offset = 0x1BE; offset < 0x1FE; offset += 16){

if(!ufatExtRead(0, offset, 16, record)) return 0;
if(record[4] != 1 && record[4] != 4 && record[4] != 6 && record[4] != 0x0B && record[4] != 0x0C && record[4] != 0x0E) continue;


diskOffset = record[11];
diskOffset = (diskOffset << 8) | record[10];
diskOffset = (diskOffset << 8) | record[9];
diskOffset = (diskOffset << 8) | record[8];
if(ufatMount()) return 1;
}

return 0;
}

static u16 ufatGetU16(const char* v, u8 idx){

v += idx;
return (((u16)v[1]) << 8) | ((u16)v[0]);
}

static u32 ufatGetU32(const char* v, u8 idx){

v += idx;
return (((u32)v[3]) << 24) | (((u32)v[2]) << 16) | (((u32)v[1]) << 8) | ((u32)v[0]);
}

void ufatInit(void){

diskOffset = 0;
}

bool ufatMount(void){

char buf[13];

if(!ufatExtRead(diskOffset, 0x36, 4, buf)) return 0;
if(buf[0] !='F' || buf[1] !='A' || buf[2] != 'T' || buf[3] != '1'){

return ufatParsePartitionTable();
}

if(!ufatExtRead(diskOffset, 0x0B, 13, buf)) return 0;
if(ufatGetU16(buf, 0x0B - 0x0B) != 512) return 0;
secPerClus = buf[0x0D - 0x0B];
fatSec = ufatGetU16(buf, 0x0E - 0x0B);
rootDirEntries = ufatGetU16(buf, 0x11 - 0x0B);
sectorsPerFat = ufatGetU16(buf, 0x16 - 0x0B);

rootSec = fatSec + sectorsPerFat * (u16)(buf[0x10 - 0x0B]);
dataSec = rootSec + (((u32)rootDirEntries) * 32 + 512 - 1) / 512;

return 1;
}

bool ufatGetNthFile(u16 n, char* name, u32* sz, u8* flags, u16* id){

u16 i;
u32 sec = diskOffset + rootSec;
u16 offset = 0;
u8 buf[4];

for(i = 0; i < rootDirEntries; i++){

if(!ufatExtRead(sec, offset, 1, buf)) return 0;
if(buf[0] == 0) break;
if(buf[0] != 0xE5 && buf[0] != 0x2E){

if(!n--){

if(name){

name[0] = (buf[0] == 0x05) ? 0xE5 : buf[0];
if(!ufatExtRead(sec, offset + 1, 10, name + 1)) return 0;
}

if(flags){

if(!ufatExtRead(sec, offset + 0x0B, 1, flags)) return 0;
}

if(id){

if(!ufatExtRead(sec, offset + 0x1A, 2, buf)) return 0;
*id = ufatGetU16(buf, 0);
}

if(sz){

if(!ufatExtRead(sec, offset + 0x1C, 4, buf)) return 0;
*sz = ufatGetU32(buf, 0);
}

return 1;
}
}
offset += 32;
if(offset == 512){
offset = 0;
sec++;
}
}


return 0;
}

bool ufatOpen(u16 id){

curClus = id;
return 1;
}

u16 ufatGetNextClus(u16 clus){

char buf[2];
u32 sec = diskOffset + fatSec;
u16 offset;

sec += clus / (512 / 2);
offset = (clus % (512 / 2)) * 2;

if(!ufatExtRead(sec, offset, 2, buf)) return 0xffff;

clus = ufatGetU16(buf, 0);
if(clus >= 0xfff8) return 0xffff;

return clus;
}
bool ufatGetNextSectorRange(u32* first, u32* len){

u16 next = curClus, prev;
u32 t;


if(curClus == 0xffff) return 0;

do{

prev = next;
next = ufatGetNextClus(prev);
}while(next == prev + 1 && next != 0xffff);




t = prev + 1 - curClus;
t *= secPerClus;
*len = t;

t = (curClus - 2);
t *= secPerClus;
t += dataSec;
t += diskOffset;
*first = t;

curClus = next;

return 1;
}
